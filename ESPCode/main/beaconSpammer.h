/*
    This declaration gives access to the esp_wifi_80211_tx function,
    which gives the ability to send raw arbitrary 802.11 frames.
*/
esp_err_t esp_wifi_80211_tx(wifi_interface_t ifx, const void *buffer, int len, bool en_sys_seq);

void beaconSpammer(){
    // Read the full command from the host
    // This will give a list of SSIDs to spam
    int cmdLen = 128;
    char* cmd = (char*)malloc(cmdLen * sizeof(char));
    int pos = 0;
    int c = 0;
    while(c != '\n'){
        do{
            c=getchar();
        }while(c==-1);
        cmd[pos] = c;
        pos++;
        if(pos >= cmdLen){
            cmdLen += 128;
            cmd = (char*)realloc(cmd, cmdLen * sizeof(char));
        }
    }
    cmd[pos-1] = '\0'; // Remove the newline character

    // Parse the command
    int ssidCount = 0;
    int ssidArrLen = 10;
    char** ssids = malloc(ssidArrLen * sizeof(char*));
    char delim[] = {0x03, 0x00};
    char* ssid = strtok(cmd, delim);
    while(ssid != NULL){
        ssids[ssidCount] = (char*)malloc((strlen(ssid)+1) * sizeof(char));
        strcpy(ssids[ssidCount], ssid);
        ssidCount++;
        if(ssidCount >= ssidArrLen){
            ssidArrLen += 10;
            ssids = (char**)realloc(ssids, ssidArrLen * sizeof(char*));
        }
        ssid = strtok(NULL, delim);
    }
    free(cmd);

    // For debugging/testing, just print the SSIDs for now:
    printf("Finished reading SSIDs\n");
    printf("Read the following SSIDs:\n");
    for(int i=0; i<ssidCount; i++){
        printf("%d: %s\n", i, ssids[i]);
    }

    // Assemble a test beacon frame

/*
"0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4e, 0x0d, 0xfd, 0x41, 0xf0, 0x1f,"
"0x4e, 0x0d, 0xfd, 0x41, 0xf0, 0x1f, 0xc0, 0x05, 0x26, 0x23, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00,"
"0x64, 0x00, 0x11, 0x04, 0x00, 0x12, 0x47, 0x61, 0x6c, 0x61, 0x78, 0x79, 0x20, 0x41, 0x35, 0x33,"
"0x20, 0x35, 0x47, 0x20, 0x36, 0x36, 0x35, 0x36, 0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12,"
"0x18, 0x24, 0x32, 0x04, 0x30, 0x48, 0x60, 0x6c, 0x03, 0x01, 0x0b, 0x05, 0x04, 0x00, 0x02, 0x00,"
"0x00, 0x2a, 0x01, 0x04, 0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f,"
"0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x02, 0x0c, 0x00, 0x2d, 0x1a, 0x2d, 0x09, 0x17, 0xff,"
"0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,"
"0x00, 0x00, 0x00, 0x00, 0x3d, 0x16, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,"
"0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x08, 0x01, 0x00,"
"0x00, 0x00, 0x00, 0x40, 0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x01, 0x00, 0x03, 0xa4,"
"0x00, 0x00, 0x27, 0xa4, 0x00, 0x00,
*/
    uint8_t beaconFrame[] = {
        0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4e, 0x0d, 0xfd, 0x41, 0xf0, 0x1f,
        0x4e, 0x0d, 0xfd, 0x41, 0xf0, 0x1f, 0xc0, 0x05, 0x26, 0x23, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00,
        0x64, 0x00, 0x11, 0x04, 0x00, 0x12, 0x47, 0x61, 0x6c, 0x61, 0x78, 0x79, 0x20, 0x41, 0x35, 0x33,
        0x20, 0x35, 0x47, 0x20, 0x36, 0x36, 0x35, 0x36, 0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12,
        0x18, 0x24, 0x32, 0x04, 0x30, 0x48, 0x60, 0x6c, 0x03, 0x01, 0x0b, 0x05, 0x04, 0x00, 0x02, 0x00,
        0x00, 0x2a, 0x01, 0x04, 0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f,
        0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x02, 0x0c, 0x00, 0x2d, 0x1a, 0x2d, 0x09, 0x17, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3d, 0x16, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x08, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x40, 0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x01, 0x00, 0x03, 0xa4,
        0x00, 0x00, 0x27, 0xa4, 0x00, 0x00,
    };  


    // Initialize NVS
	esp_err_t ret = nvs_flash_init();
	if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
		ESP_ERROR_CHECK(nvs_flash_erase());
		ret = nvs_flash_init();
	}
	ESP_ERROR_CHECK(ret);

	ESP_ERROR_CHECK(esp_netif_init());
	ESP_ERROR_CHECK(esp_event_loop_create_default());
	esp_netif_create_default_wifi_ap();

	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();

	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));

	// Init dummy AP to specify a channel and get WiFi hardware into
	// a mode where we can send the actual fake beacon frames.
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
	wifi_config_t ap_config = {
		.ap = {
			.ssid = "esp32-beaconspam",
			.ssid_len = 0,
			.password = "dummypassword",
			.channel = 11,
			.authmode = WIFI_AUTH_WPA2_PSK,
			.ssid_hidden = 1,
			.max_connection = 4,
			.beacon_interval = 60000
		}
	};

	ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_config));
	ESP_ERROR_CHECK(esp_wifi_start());
	ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE));

    // Send the beacon frame every 100ms
    while(1){
        //esp_wifi_80211_tx(WIFI_IF_AP, beaconFrame, sizeof(beaconFrame), false);
        // Version with debug:
        esp_err_t err = esp_wifi_80211_tx(WIFI_IF_AP, beaconFrame, sizeof(beaconFrame), false);
        if(err != ESP_OK){
            printf("Error sending beacon frame: %d\r\n", err);
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }

}

TaskHandle_t beaconSpammerTaskHandle;

void runBeaconSpammer(){
    xTaskCreate(beaconSpammer, "beaconSpammer", 4096, NULL, 5, &beaconSpammerTaskHandle);
    while(getchar() != 'q'){ // Wait for 'q' to be sent by host
        vTaskDelay(10 / portTICK_PERIOD_MS); // 10ms delay reduces cpu usage
    }
    vTaskDelete(beaconSpammerTaskHandle);
}